library ieee;
use ieee.std_logic_1164.all;

library std;
use std.textio.all;

library amp;
use amp.prelude.all;

library vertex;

entity bcd_enc_tb is
    generic (
        LEN: positive := 4;
        DIGITS: positive := 2
    );
end entity;

architecture sim of bcd_enc_tb is
    use vertex.test.all;

    -- This record is auto-generated by vertex. DO NOT EDIT.
    type bcd_enc_bfm is record
        go: logic;
        bin: logics(LEN-1 downto 0);
        bcd: logics((4*DIGITS)-1 downto 0);
        ovfl: logic;
        done: logic;
    end record;

    signal bfm: bcd_enc_bfm;

    signal clk: logic;
    signal rst: logic;
    signal halt: boolean := false;

    --! declare internal required testbench signals
    constant TIMEOUT_LIMIT: natural := 100;

    file events: text open write_mode is "events.log";

begin

    -- instantiate UUT
    UUT: entity work.bcd_enc
    generic map (
        LEN   => LEN,
        DIGITS => DIGITS
    ) port map (
        rst   => rst,
        clk   => clk,
        go    => bfm.go,
        bin   => bfm.bin,
        bcd   => bfm.bcd,
        done  => bfm.done,
        ovfl  => bfm.ovfl
    );

    --! generate a 50% duty cycle for 25 Mhz
    spin_clock(clk, 40 ns, halt);

    --! test reading a file filled with test vectors
    driver: process
        file inputs: text open read_mode is "inputs.txt";

        -- This procedure is auto-generated by vertex. DO NOT EDIT.
        procedure drive_transaction(file fd: text) is 
            variable row: line;
        begin
            if endfile(fd) = false then
                -- drive a transaction
                readline(fd, row);
                drive(row, bfm.go);
                -- vertex.log_event(events, vertex.TRACE, "DRIVE", "go - " & to_str(bfm.go));
                drive(row, bfm.bin);
                -- vertex.log_event(events, vertex.TRACE, "DRIVE", "bin - " & to_str(bfm.bin));
            end if;
        end procedure; 

    begin  
        -- initialize input signals      
        drive_transaction(inputs);
        trigger_reset_h(clk, rst, 3);
        wait until rising_edge(clk);

        -- drive transactions
        while endfile(inputs) = false loop
            drive_transaction(inputs);
            wait until rising_edge(clk);
        end loop;

        -- wait for all outputs to be checked
        wait;
    end process;

    monitor: process
        file outputs: text open read_mode is "outputs.txt";
        variable timeout: bool;

        procedure score_transaction(file fd: text) is
            variable row: line;
            variable expct: bcd_enc_bfm;
        begin
            if endfile(fd) = false then
                -- compare received outputs with expected outputs
                readline(fd, row);
                load(row, expct.bcd);
                assert_eq(events, bfm.bcd, expct.bcd, "bcd");

                load(row, expct.done);
                assert_eq(events, bfm.done, expct.done, "done");
                
                load(row, expct.ovfl);
                assert_eq(events, bfm.ovfl, expct.ovfl, "ovfl");
            end if;
        end procedure;
        
    begin
        monitor_l(events, clk, rst, TIMEOUT_LIMIT, timeout, "rst");

        while endfile(outputs) = false loop
            -- @note: should monitor detect rising edge or when = '1'? ... when = '1' will delay by a cycle, which could not be the intention
            -- @todo: have better handling of monitor process (WIP, might be good now)

            -- wait for a valid time to check
            monitor_h(events, clk, bfm.done, TIMEOUT_LIMIT, timeout, "done");

            -- compare outputs
            score_transaction(outputs);
            -- wait for done to be lowered before starting monitor
            wait until falling_edge(bfm.done);
        end loop;

        -- halt the simulation
       complete(halt);
    end process;

    -- concurrent captures of simulation
    stabilize_h(events, clk, bfm.done, bfm.bcd, "bcd depending on done");

end architecture;